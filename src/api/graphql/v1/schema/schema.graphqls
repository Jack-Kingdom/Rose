schema {
    query: Query
    mutation: Mutation
}

type Query {

    articles(order:String = "-updatedAt",offset: Int = 0,limit:Int = 10, status:status=published):[Article]
    categories(order:String = "-updatedAt",offset: Int = 0,limit:Int = 10):[Category]
    tags(order:String = "-updatedAt",offset: Int = 0,limit:Int = 10):[Tag]

    article(slug:String!):Article
    category(slug:String!):Category
    tag(slug:String!):Tag
}

type Mutation {

    #    createArticle(params:ArticleInput):ReturnType
    #    updateArticle(params:ArticleInput):ReturnType
    #    deleteArticle(slug:ID!):ReturnType
    #
    #    createCategory(params:CategoryInput):ReturnType
    #    updateCategory(params:CategoryInput):ReturnType
    #    deleteCategory(slug:ID!):ReturnType
    #
    createTag(params:TagInput):ReturnType
    #    updateTag(params:TagInput):ReturnType
    #    deleteTag(slug:ID!):ReturnType
}

interface Base{
    slug: String!
    title: String
}

type Article implements Base{
    slug:String!
    title:String
    content:String
    renderedContent:String
    category: Category
    tags: [Tag]
    status: status
    allowComments: Boolean
    createdAt: Int
    updatedAt: Int
}

input ArticleInput{
    slug:String!
    title:String
    content:String
    renderedContent:String
    category: String    # use slug as reference
    tags: [String]      # as same
    status: status
    allowComments: Boolean
    createdAt: Int
    updatedAt: Int
}


type Category implements Base{
    slug: String!
    title: String
    articles:[Article]
}

input CategoryInput {
    slug: String!
    title: String
}

type Tag implements Base{
    slug: String!
    title: String
    articles:[Article]
}

input TagInput {
    slug: String!
    title: String
}

enum status {
    published
    draft
    removed
}

type ReturnType {
    success:Boolean!
    message:String
}